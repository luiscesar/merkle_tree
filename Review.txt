Code Review

- The tree functions are implemented in a very efficient way.

- The function declarations are clear and well commented.

- There is a resistance test that shows the robustness of the function
  that generates the tree under heavy loads.


- Test test_generate_path_1 failed  

   Because the required path is bottom-up and not top-down.  
   In order to fix it, in lines 292 and 294, use push instead of insert.

       292:  Instead of merkle_path.insert(0, right_node):

                 merkle_path.push(right_node);

       294:  Instead of merkle_path.insert(0, left_node):

                merkle_path.push(left_node);


- Library crate  
   
   It may be helpful to structure the project as a library
   which can be used in other crates (microservices, software components)


- Loops v recursive calls

  Recursive calls are very expressive but Tail Call Optimization is not implemented in Rust.  
  That means even if the recursive call is a tail recursive one,
  all recursive calls are stored in Stack, with the risk of having Stack Overflow.
 

- Abstract Data Type definition

  Using Abstract Data Types (ADT) may help to utilize separation of concerns
  during the design process.

  Each ADT will be described by a set of responsibilities: functions.

  Also, it can be used as a contract to be implemented by a concrete type or by a software component (group of types collaborating with each other).
 
  Moreover, it may help the maintenance as the contract may be the same (client code may need small changes)
  and the implementation may vary.
 
  In Rust, ADTs can be realized using Traits.
  In order to use Traits, concrete types have to be expressed using struct or enum.


- Balanced Merkle Tree
   
  The current implementation does not generate a balanced binary tree in all cases.
  It may be useful to have a balanced implementation for all cases.
  A possible implementation called BalancedMerkleTree has been proposed.
 
  Let n be the number of leaves.
  For example:
  When n = 5 the current implementation generates the following tree:

                                            h(h(h(h(1)||h(2))||h(h(3)||h(4)))||h(5))
 
                      h(h(h(1)||h(2))||h(h(3)||h(4)))                               h(5)    
         
            h(h(1)||h(2))                         h(h(3)||h(4))
   
        h(1)              h(2)                 h(3)             h(4)


And the balanced one generates the tree:
                                          h(h(h(h(1)||h(2))||h(3)||h(h(4)||h(5)))

                     h(h(h(1)||h(2))||h(3)                                         h(h(4)||h(5))

        h(h(1)||h(2))                     h(3)                                  h(4)             h(5)

    h(1)             h(2)

In general:
If n = 2^t for t > 0, integer, the leaves are the leaves of a complete tree, and they are at level t.
If n = 2^t + y for t, 0 < y < 2^t, integers, the leaves are split in two levels: t+1 and t.
In order to have a balanced tree it is necessary to know which number of leaves is at t+1 and which at level t.
Moreover, in the way that the hash tree is constructed we can assume that all nodes have a number even of children.
Thus the level t + 1 will incompleted with the number even of nodes and level t will be completed with 2^t nodes.
Therefore in order to know the number of leaves at level t+1 and at level t, respectively,
the following equation system has to be solved:
   
  (n - x) = 2 * q
    x + q = 2^t

where x is the number of leaves at level t and 2 * q is the number of leaves at level t+1.


- All types defined inside the components (modules)

  It may help the maintenance to have all types that belong to the function signatures
  that are exported, defined inside the component (module).
  This will also include the Error types.
  This may imply having internal Error type definitions or wrapping certain Rust standard types.
 
- Software components: Module structure

   It may be helpful to split the project into different software components:
groups of computational elements (types, modules, funcitions) collaborating with each other in order to realize specified features.
   
   In Rust this can be achieved using modules.


- Unit tests in a separated module  

  It may be helpful to describe Types and their Unit Tests in different files.

  This may provide a better readiness in case that the Type declaration (set of functions) grows or the test cases increase.  
 
  In Rust this can achieved by writing the tests in a submodule of the Type called tests and
  marking it with the attribute #[cfg(test)]    


- Integration tests
   
  It may be helpful to have integration tests which will allow the software component (crate) features to be verified
  by an external client.